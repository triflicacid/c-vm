# Instructions

Below is the full list of instructions supported by the assembler.
(See `processor/src/opcodes.h` for the list of opcode numerical constants)

**IMPORTANT** The CCR has been removed.

- `CCR` : changes the instruction makes to the CCR register. Given in-order: `NZVC` -- **N**egative, **Z**ero, o**V**erflow, **C**arry.
  - `*` means the bit is changed
  - `-` means the bit is untouched
  - `0` means the bit is cleared (`= 0`)
  - `1` means the bit is set (`= 1`)


| Mnemonic | Fully Qualified Name | Arguments                                         | Description                                                                                                   | Example                 | CCR    |
|----------|----------------------|---------------------------------------------------|---------------------------------------------------------------------------------------------------------------|-------------------------|--------|
| add      | OP_ADD_REG_LIT       | `<reg: u8>`, `<lit: word>`                        | Add a register and a literal as integers                                                                      | `add r1, 10`            | `----` |
| add      | OP_ADD_REG_REG       | `<reg: u8>`, `<reg: u8>`                          | Add two registers as integers, storing the result in the first register                                       | `add r1, r2`            | `----` |
| add      | OP_ADD_MEM_MEM       | `<bytes: u8>`, `<addr1: uword>`, `<addr2: uword>` | Add two n-bytes buffers at the addresses and store result at the first address                                | `add 128, [200], [328]` | `----` |
| add      | OP_ADD_MEM_LIT       | `<bytes: u8>`, `<addr: uword>`, `<lit: u8>`       | Add an unsigned byte into an n-byte buffer                                                                    | `add 128, [200], 1`     | `----` |
| addf32   | OP_ADDF32_REG_LIT    | `<reg: u8>`, `<lit: f32>`                         | Add a register and a literal as 32-bit floats                                                                 | `addf32 r1, 10`         | `----` |
| addf32   | OP_ADDF32_REG_REG    | `<reg: u8>`, `<reg: u8>`                          | Add two registers as 32-bit floats, storing the result in the first register                                  | `addf32 r1, r2`         | `----` |
| addf64   | OP_ADDF64_REG_LIT    | `<reg: u8>`, `<lit: f64>`                         | Add a register and a literal as 64-bit floats                                                                 | `addf64 r1, 10`         | `----` |
| addf64   | OP_ADDF64_REG_REG    | `<reg: u8>`, `<reg: u8>`                          | Add two registers as 64-bit floats, storing the result in the first register                                  | `addf64 r1, r2`         | `----` |
| and      | OP_AND_REG_LIT       | `<reg: u8>`, `<lit: word>`                        | Compute bitwise AND of register and literal and place the result in register                                  | `and r1, 101b`          | `**00` |
| and8     | OP_AND8_REG_LIT      | `<reg: u8>`, `<lit: u8>`                          | Compute bitwise AND of register and 8-bit literal and place the result in register                            | `and8 r1, 101b`         | `**00` |
| and16    | OP_AND16_REG_LIT     | `<reg: u8>`, `<lit: u16>`                         | Compute bitwise AND of register and 16-bit literal and place the result in register                           | `and16 r1, 101b`        | `**00` |
| and32    | OP_AND32_REG_LIT     | `<reg: u8>`, `<lit: u32>`                         | Compute bitwise AND of register and 32-bit literal and place the result in register                           | `and32 r1, 101b`        | `**00` |
| and64    | OP_AND64_REG_LIT     | `<reg: u8>`, `<lit: u64>`                         | Compute bitwise AND of register and 64-bit literal and place the result in register                           | `and64 r1, 101b`        | `**00` |
| and      | OP_AND_REG_REG       | `<reg: u8>`, `<reg: u8>`                          | Compute bitwise AND of two registers and place in the first register                                          | `and r1, r2`            | `**00` |
| and      | OP_AND_MEM_MEM       | `<bytes: u8>`, `<addr: uword>`, `<addr: uword>`   | Compute bitwise AND of two`byte`-length buffers at the addresses and store result in the first address        | `and 12, [200], [212]`  | `**00` |
| cal      | OP_CALL_LIT          | `<lit: uword>`                                    | Call procedure starting at address`lit`                                                                       | `cal 100`               | `----` |
| cal      | OP_CALL_REG          | `<reg: u8>`                                       | Call procedure starting at address stored in register (as unsigned int)                                       | `cal r1`                | `----` |
| ci8i16   | OP_CVT_i8_i16        | `<reg: u8>`                                       | Convert value in register from 8-bit integer to 16-bit integer                                                | `ci8i16 r2`             | `----` |
| ci16i8   | OP_CVT_i16_i8        | `<reg: u8>`                                       | Convert value in register from 16-bit integer to 8-bit integer                                                | `ci16i8 r2`             | `----` |
| ci16i32  | OP_CVT_i16_i32       | `<reg: u8>`                                       | Convert value in register from 16-bit integer to 32-bit integer                                               | `ci16i32 r2`            | `----` |
| ci32i16  | OP_CVT_i32_i16       | `<reg: u8>`                                       | Convert value in register from 32-bit integer to 16-bit integer                                               | `ci32i16 r2`            | `----` |
| ci32i64  | OP_CVT_i32_i64       | `<reg: u8>`                                       | Convert value in register from 32-bit integer to 64-bit integer                                               | `ci32i64 r2`            | `----` |
| ci64i32  | OP_CVT_i64_i32       | `<reg: u8>`                                       | Convert value in register from 64-bit integer to 32-bit integer                                               | `ci64i32 r2`            | `----` |
| ci32f32  | OP_CVT_i32_f32       | `<reg: u8>`                                       | Convert value in register from 32-bit integer to 32-bit float                                                 | `ci32f32 r2`            | `----` |
| cf32i32  | OP_CVT_f32_i32       | `<reg: u8>`                                       | Convert value in register from 32-bit float to 32-bit integer                                                 | `cf32i32 r2`            | `----` |
| ci64f64  | OP_CVT_i64_f64       | `<reg: u8>`                                       | Convert value in register from 64-bit integer to 64-bit float                                                 | `ci64f64 r2`            | `----` |
| cf64i64  | OP_CVT_f64_i64       | `<reg: u8>`                                       | Convert value in register from 64-bit float to 64-bit integer                                                 | `cf64i64 r2`            | `----` |
| cmp      | OP_CMP_REG_REG       | `<reg: u8>`, `<reg: u8>`                          | Compare the value of two registers. Set`REG_CMP` appropriately.                                               | `cmp r1, r2`            | `----` |
| cmp      | OP_CMP_REG_LIT       | `<reg: u8>`, `<lit: word>`                        | Compare the value of a register to a literal. Set`REG_CMP` appropriately.                                     | `cmp r1, 10`            | `----` |
| cmp      | OP_CMP_LIT_LIT       | `<lit: word>`, `<lit: word>`                      | Compare the value os two literal words. Set`REG_CMP` appropriately.                                           | `cmp 1, 10`             | `----` |
| cmp      | OP_CMP_MEM_MEM       | `<bytes: u8>`, `<addr1: uword>`, `<addr2: uword>` | Compare the value of two n-byte buffers. Set`REG_CMP` appropriately.                                          | `cmp 12, [200], [212]`  | `----` |
| cmpf32   | OP_CMPF32_REG_REG    | `<reg: u8>`, `<reg: u8>`                          | Compare the value of two registers as 32-bit floats. Set`REG_CMP` appropriately.                              | `cmpf32 r1, r2`         | `----` |
| cmpf32   | OP_CMPF32_REG_LIT    | `<reg: u8>`, `<lit: f32>`                         | Compare the value of two registers as 32-bit floats. Set`REG_CMP` appropriately.                              | `cmpf32 r1, 10`         | `----` |
| cmpf64   | OP_CMPF64_REG_REG    | `<reg: u8>`, `<reg: u8>`                          | Compare the value of two registers as 64-bit floats. Set`REG_CMP` appropriately.                              | `cmpf64 r1, r2`         | `----` |
| cmpf64   | OP_CMPF64_REG_LIT    | `<reg: u8>`, `<lit: f64>`                         | Compare the value of two registers as 64-bit floats. Set`REG_CMP` appropriately.                              | `cmpf64 r1, 10`         | `----` |
| div      | OP_DIV_REG_LIT       | `<reg: u8>`, `<lit: word>`                        | Divide a register by a literal as integers. Store remainder in`REG_FLAG`.                                     | `div r1, 10`            | `----` |
| div      | OP_DIV_REG_REG       | `<reg: u8>`, `<reg: u8>`                          | Divide two registers as integers, storing the result in the first register. Store remainder in`REG_FLAG`.     | `div r1, r2`            | `----` |
| divf32   | OP_DIVF32_REG_LIT    | `<reg: u8>`, `<lit: f32>`                         | Divide a register by a literal as 32-bit floats                                                               | `divf32 r1, 10`         | `----` |
| divf32   | OP_DIVF32_REG_REG    | `<reg: u8>`, `<reg: u8>`                          | Divide two registers as 32-bit floats, storing the result in the first register                               | `divf32 r1, r2`         | `----` |
| divf64   | OP_DIVF64_REG_LIT    | `<reg: u8>`, `<lit: f64>`                         | Divide a register by a literal as 64-bit floats                                                               | `divf64 r1, 10`         | `----` |
| divf64   | OP_DIVF64_REG_REG    | `<reg: u8>`, `<reg: u8>`                          | Divide two registers as 64-bit floats, storing the result in the first register                               | `divf64 r1, r2`         | `----` |
| hlt      | OP_HALT              |                                                   | Stop execution                                                                                                | `hlt`                   | `----` |
| jmp      | OP_JMP_LIT           | `<lit: uword>`                                    | Jump to a given literal address                                                                               | `jmp 100h`              | `----` |
| jmp      | OP_JMP_REG           | `<reg: u8>`                                       | Jump to a given address in a register                                                                         | `jmp r3`                | `----` |
| jeq      | OP_JMP_EQ_LIT        | `<lit: uword>`                                    | Jump to a given literal address if last comparison is`CMP_EQ`                                                 | `jeq 100h`              | `----` |
| jeq      | OP_JMP_EQ_REG        | `<reg: u8>`                                       | Jump to a given address in a register if last comparison is`CMP_EQ`                                           | `jeq r3`                | `----` |
| jne      | OP_JMP_NEQ_LIT       | `<lit: uword>`                                    | Jump to a given literal address if last comparison is not`CMP_EQ`                                             | `jne 100h`              | `----` |
| jne      | OP_JMP_NEQ_REG       | `<reg: u8>`                                       | Jump to a given address in a register if last comparison is not`CMP_EQ`                                       | `jne r3`                | `----` |
| jlt      | OP_JMP_LT_LIT        | `<lit: uword>`                                    | Jump to a given literal address if last comparison is`CMP_LT`                                                 | `jlt 100h`              | `----` |
| jlt      | OP_JMP_LT_REG        | `<reg: u8>`                                       | Jump to a given address in a register if last comparison is`CMP_LT`                                           | `jlt r3`                | `----` |
| jgt      | OP_JMP_GT_LIT        | `<lit: uword>`                                    | Jump to a given literal address if last comparison is`CMP_GT`                                                 | `jgt 100h`              | `----` |
| jgt      | OP_JMP_GT_REG        | `<reg: u8>`                                       | Jump to a given address in a register if last comparison is`CMP_GT`                                           | `jgt r3`                | `----` |
| mov      | OP_MOV_LIT_REG       | `<lit: word>`, `<reg: u8>`                        | Move literal word into register`reg`                                                                          | `mov 100h, r3`          | `----` |
| mov8     | OP_MOV8_LIT_REG      | `<lit: u8>`, `<reg: u8>`                          | Move 8-bit literal into register`reg`                                                                         | `mov8 100, r3`          | `----` |
| mov16    | OP_MOV16_LIT_REG     | `<lit: u16>`, `<reg: u8>`                         | Move 16-bit literal word into register`reg`                                                                   | `mov16 100, r3`         | `----` |
| mov32    | OP_MOV32_LIT_REG     | `<lit: u32>`, `<reg: u8>`                         | Move 32-bit literal word into register`reg`                                                                   | `mov32 100, r3`         | `----` |
| mov64    | OP_MOV64_LIT_REG     | `<lit: u64>`, `<reg: u8>`                         | Move 64-bit literal word into register`reg`                                                                   | `mov64 100h, r3`        | `----` |
| mov      | OP_MOV_LIT_MEM       | `<lit: word>`, `<addr: uword>`                    | Move literal word to address                                                                                  | `mov 100h, [128]`       | `----` |
| mov8     | OP_MOV8_LIT_MEM      | `<lit: u8>`, `<addr: uword>`                      | Move 8-bit literal to address                                                                                 | `mov8 100, [128]`       | `----` |
| mov16    | OP_MOV16_LIT_MEM     | `<lit: u16>`, `<addr: uword>`                     | Move 16-bit literal to address                                                                                | `mov16 100, [128]`      | `----` |
| mov32    | OP_MOV32_LIT_MEM     | `<lit: u32>`, `<addr: uword>`                     | Move 32-bit literal to address                                                                                | `mov32 100, [128]`      | `----` |
| mov64    | OP_MOV64_LIT_MEM     | `<lit: u64>`, `<addr: uword>`                     | Move 64-bit literal to address                                                                                | `mov64 100h, [128]`     | `----` |
| mov      | OP_MOV_LIT_OFF_REG   | `<reg: u8>`, `<lit: word>`, `<reg: u8>`           | Fetch value from register, add literal, and move the word at that address to the destination register         | `mov r1, 32, r2`        | `----` |
| mov8     | OP_MOV8_LIT_OFF_REG  | `<reg: u8>`, `<lit: word>`, `<reg: u8>`           | Fetch value from register, add literal, and move the 8-bit value at that address to the destination register  | `mov8 r1, 32, r2`       | `----` |
| mov16    | OP_MOV16_LIT_OFF_REG | `<reg: u8>`, `<lit: word>`, `<reg: u8>`           | Fetch value from register, add literal, and move the 16-bit value at that address to the destination register | `mov16 r1, 32, r2`      | `----` |
| mov32    | OP_MOV32_LIT_OFF_REG | `<reg: u8>`, `<lit: word>`, `<reg: u8>`           | Fetch value from register, add literal, and move the 32-bit value at that address to the destination register | `mov32 r1, 32, r2`      | `----` |
| mov64    | OP_MOV64_LIT_OFF_REG | `<reg: u8>`, `<lit: word>`, `<reg: u8>`           | Fetch value from register, add literal, and move the 64-bit value at that address to the destination register | `mov64 r1, 32, r2`      | `----` |
| mov      | OP_MOV_MEM_REG       | `<addr: uword>`, `<reg: u8>`                      | Move value at address to register                                                                             | `mov [1Fh], r2`         | `----` |
| mov8     | OP_MOV8_MEM_REG      | `<addr: uword>`, `<reg: u8>`                      | Move 8-bit value at address to register                                                                       | `mov8 [1Fh], r2`        | `----` |
| mov16    | OP_MOV16_MEM_REG     | `<addr: uword>`, `<reg: u8>`                      | Move 16-bit value at address to register                                                                      | `mov16 [1Fh], r2`       | `----` |
| mov32    | OP_MOV32_MEM_REG     | `<addr: uword>`, `<reg: u8>`                      | Move 32-bit value at address to register                                                                      | `mov32 [1Fh], r2`       | `----` |
| mov64    | OP_MOV64_MEM_REG     | `<addr: uword>`, `<reg: u8>`                      | Move 64-bit value at address to register                                                                      | `mov64 [1Fh], r2`       | `----` |
| mov      | OP_MOV_REG_MEM       | `<reg: u8>`, `<addr: uword>`                      | Move value in register to address                                                                             | `mov r2, [1Fh]`         | `----` |
| mov8     | OP_MOV8_REG_MEM      | `<reg: u8>`, `<addr: uword>`                      | Move 8-bit value from register to the address                                                                 | `mov8 r2, [1Fh]`        | `----` |
| mov16    | OP_MOV16_REG_MEM     | `<reg: u8>`, `<addr: uword>`                      | Move 16-bit value from register to the address                                                                | `mov16 r2, [1Fh]`       | `----` |
| mov32    | OP_MOV32_REG_MEM     | `<reg: u8>`, `<addr: uword>`                      | Move 32-bit value from register to the address                                                                | `mov32 r2, [1Fh]`       | `----` |
| mov64    | OP_MOV64_REG_MEM     | `<reg: u8>`, `<addr: uword>`                      | Move 64-bit value from register to the address                                                                | `mov64 r2, [1Fh]`       | `----` |
| mov      | OP_MOV_REGPTR_REG    | `<regptr: u8>`, `<reg: u8>`                       | Move value at memory address stored in first register to second register                                      | `mov [r1], r2`          | `----` |
| mov8     | OP_MOV8_REGPTR_REG   | `<regptr: u8>`, `<reg: u8>`                       | Move 8-bit value at memory address stored in first register to second register                                | `mov8 [r1], r2`         | `----` |
| mov16    | OP_MOV16_REGPTR_REG  | `<regptr: u8>`, `<reg: u8>`                       | Move 16-bit value at memory address stored in first register to second register                               | `mov16 [r1], r2`        | `----` |
| mov32    | OP_MOV32_REGPTR_REG  | `<regptr: u8>`, `<reg: u8>`                       | Move 32-bit value at memory address stored in first register to second register                               | `mov32 [r1], r2`        | `----` |
| mov64    | OP_MOV64_REGPTR_REG  | `<regptr: u8>`, `<reg: u8>`                       | Move 64-bit value at memory address stored in first register to second register                               | `mov64 [r1], r2`        | `----` |
| mov      | OP_MOV_REG_REGPTR    | `<reg: u8>`, `<regptr: u8>`                       | Move value in first register to memory address stored in the second register                                  | `mov r1, [r2]`          | `----` |
| mov8     | OP_MOV8_REG_REGPTR   | `<reg: u8>`, `<regptr: u8>`                       | Move 8-bit value in first register to memory address stored in the second register                            | `mov8 r1, [r2]`         | `----` |
| mov16    | OP_MOV16_REG_REGPTR  | `<reg: u8>`, `<regptr: u8>`                       | Move 16-bit value in first register to memory address stored in the second register                           | `mov16 r1, [r2]`        | `----` |
| mov32    | OP_MOV32_REG_REGPTR  | `<reg: u8>`, `<regptr: u8>`                       | Move 32-bit value in first register to memory address stored in the second register                           | `mov32 r1, [r2]`        | `----` |
| mov64    | OP_MOV64_REG_REGPTR  | `<reg: u8>`, `<regptr: u8>`                       | Move 64-bit value in first register to memory address stored in the second register                           | `mov64 r1, [r2]`        | `----` |
| mov      | OP_MOV_REG_REG       | `<reg: u8>`, `<reg: u8>`                          | Move value in first register to second register                                                               | `mov r1, r2`            | `----` |
| mul      | OP_MUL_REG_LIT       | `<reg: u8>`, `<lit: word>`                        | Multiply a register by a literal as integers                                                                  | `mul r1, 10`            | `----` |
| mul      | OP_MUL_REG_REG       | `<reg: u8>`, `<reg: u8>`                          | Multiply two registers as integers, storing the result in the first register                                  | `mul r1, r2`            | `----` |
| mulf32   | OP_MULF32_REG_LIT    | `<reg: u8>`, `<lit: f32>`                         | Multiply a register by a literal as 32-bit floats                                                             | `mulf32 r1, 10`         | `----` |
| mulf32   | OP_MULF32_REG_REG    | `<reg: u8>`, `<reg: u8>`                          | Multiply two registers as 32-bit floats, storing the result in the first register                             | `mulf32 r1, r2`         | `----` |
| mulf64   | OP_MULF64_REG_LIT    | `<reg: u8>`, `<lit: f64>`                         | Multiply a register by a literal as 64-bit floats                                                             | `mulf64 r1, 10`         | `----` |
| mulf64   | OP_MULF64_REG_REG    | `<reg: u8>`, `<reg: u8>`                          | Multiply two registers as 64-bit floats, storing the result in the first register                             | `mulf64 r1, r2`         | `----` |
| neg      | OP_NEG               | `<reg: u8>`                                       | Negate value in register (twos complement)                                                                    | `neg r3`                | `**00` |
| negf32   | OP_NEGF32            | `<reg: u8>`                                       | Negate 32-bit floating point value in register                                                                | `negf32 r3`             | `**00` |
| negf64   | OP_NEGF64            | `<reg: u8>`                                       | Negate 64-bit floating point value in register                                                                | `negf64 r3`             | `**00` |
| not      | OP_NOT_REG           | `<reg: u8>`                                       | Compute bitwise NOT of a register in-place                                                                    | `not r3`                | `**00` |
| not      | OP_NOT_MEM           | `<bytes: u8>`, `<addr: uword>`                    | Compute bitwise NOT of a`byte`-length buffer at given address in-place                                        | `not 128, [100]`        | `**00` |
| or       | OP_OR_REG_LIT        | `<reg: u8>`, `<lit: word>`                        | Compute bitwise OR of register and literal and place the result in register                                   | `or r1, 101b`           | `**00` |
| or8      | OP_OR8_REG_LIT       | `<reg: u8>`, `<lit: u8>`                          | Compute bitwise OR of register and 8-bit literal and place the result in register                             | `or8 r1, 101b`          | `**00` |
| or16     | OP_OR16_REG_LIT      | `<reg: u8>`, `<lit: u16>`                         | Compute bitwise OR of register and 16-bit literal and place the result in register                            | `or16 r1, 101b`         | `**00` |
| or32     | OP_OR32_REG_LIT      | `<reg: u8>`, `<lit: u32>`                         | Compute bitwise OR of register and 32-bit literal and place the result in register                            | `or32 r1, 101b`         | `**00` |
| or64     | OP_OR64_REG_LIT      | `<reg: u8>`, `<lit: u64>`                         | Compute bitwise OR of register and 64-bit literal and place the result in register                            | `or64 r1, 101b`         | `**00` |
| or       | OP_OR_REG_REG        | `<reg: u8>`, `<reg: u8>`                          | Compute bitwise OR of two registers and place the result in the first register                                | `or r1, r2`             | `**00` |
| or       | OP_OR_MEM_MEM        | `<bytes: u8>`, `<addr: uword>`, `<addr: uword>`   | Compute bitwise OR of two`byte`-length buffers at the addresses and store result in the first address         | `or 12, [200], [212]`   | `**00` |
| pop      | OP_POP_REG           | `<reg: u8>`                                       | Pop value from the stack and load into register                                                               | `pop r1`                | `----` |
| pop8     | OP_POP8_REG          | `<reg: u8>`                                       | Pop 8-bit value from the stack and load into register                                                         | `pop8 r1`               | `----` |
| pop16    | OP_POP16_REG         | `<reg: u8>`                                       | Pop 16-bit value from the stack and load into register                                                        | `pop16 r1`              | `----` |
| pop32    | OP_POP32_REG         | `<reg: u8>`                                       | Pop 32-bit value from the stack and load into register                                                        | `pop32 r1`              | `----` |
| pop64    | OP_POP64_REG         | `<reg: u8>`                                       | Pop 64-bit value from the stack and load into register                                                        | `pop64 r1`              | `----` |
| pop      | OP_POP_REGPTR        | `<regptr: u8>`                                    | Pop value from the stack and load into address in register                                                    | `pop [r1]`              | `----` |
| pop8     | OP_POP8_REGPTR       | `<regptr: u8>`                                    | Pop 8-bit value from the stack and load into address in register                                              | `pop8 [r1]`             | `----` |
| pop16    | OP_POP16_REGPTR      | `<regptr: u8>`                                    | Pop 16-bit value from the stack and load into address in register                                             | `pop16 [r1]`            | `----` |
| pop32    | OP_POP32_REGPTR      | `<regptr: u8>`                                    | Pop 32-bit value from the stack and load into address in register                                             | `pop32 [r1]`            | `----` |
| pop64    | OP_POP64_REGPTR      | `<regptr: u8>`                                    | Pop 64-bit value from the stack and load into address in register                                             | `pop64 [r1]`            | `----` |
| pop      | OP_POPN_REGPTR       | `<bytes: u8>`, `<regptr: u8>`                     | Pop n-byte value from the stack and load into address in register                                             | `pop 12, [r1]`          | `----` |
| pop      | OP_POPN_MEM          | `<bytes: u8>`, `<addr: uword>`                    | Pop n-byte value from the stack and load into address                                                         | `pop 12, [100]`         | `----` |
| psh      | OP_PUSH_LIT          | `<lit: word>`                                     | Push a literal onto the stack                                                                                 | `psh 101`               | `----` |
| psh8     | OP_PUSH8_LIT         | `<lit: u8>`                                       | Push an 8-bit literal onto the stack                                                                          | `psh8 101`              | `----` |
| psh16    | OP_PUSH16_LIT        | `<lit: u16>`                                      | Push a 16-bit literal onto the stack                                                                          | `psh16 101`             | `----` |
| psh32    | OP_PUSH32_LIT        | `<lit: u32>`                                      | Push a 32-bit literal onto the stack                                                                          | `psh32 101`             | `----` |
| psh64    | OP_PUSH64_LIT        | `<lit: u64>`                                      | Push a 64-bit literal onto the stack                                                                          | `psh64 101`             | `----` |
| psh      | OP_PUSH_MEM          | `<addr: uword>`                                   | Push value at memory address onto the stack                                                                   | `psh [100]`             | `----` |
| psh8     | OP_PUSH8_MEM         | `<addr: uword>`                                   | Push 8-bit value at memory address onto the stack                                                             | `psh8 [100]`            | `----` |
| psh16    | OP_PUSH16_MEM        | `<addr: uword>`                                   | Push 16-bit value at memory address onto the stack                                                            | `psh16 [100]`           | `----` |
| psh32    | OP_PUSH32_MEM        | `<addr: uword>`                                   | Push 32-bit value at memory address onto the stack                                                            | `psh32 [100]`           | `----` |
| psh64    | OP_PUSH64_MEM        | `<addr: uword>`                                   | Push 64-bit value at memory address onto the stack                                                            | `psh64 [100]`           | `----` |
| psh      | OP_PUSHN_MEM         | `<bytes: u8>`, `<addr: uword>`                    | Push`n`-byte value at memory address onto the stack                                                           | `psh 12, [100]`         | `----` |
| psh      | OP_PUSH_REG          | `<reg: u8>`                                       | Push value in register onto the stack                                                                         | `psh r1`                | `----` |
| psh8     | OP_PUSH8_REG         | `<reg: u8>`                                       | Push 8-bit value in register onto the stack                                                                   | `psh8 r1`               | `----` |
| psh16    | OP_PUSH16_REG        | `<reg: u8>`                                       | Push 16-bit value in register onto the stack                                                                  | `psh16 r1`              | `----` |
| psh32    | OP_PUSH32_REG        | `<reg: u8>`                                       | Push 32-bit value in register onto the stack                                                                  | `psh32 r1`              | `----` |
| psh64    | OP_PUSH64_REG        | `<reg: u8>`                                       | Push 64-bit value in register onto the stack                                                                  | `psh64 r1`              | `----` |
| psh      | OP_PUSH_REGPTR       | `<reg: u8>`                                       | Push value at memory address stored in register onto the stack                                                | `psh [r1]`              | `----` |
| psh8     | OP_PUSH8_REGPTR      | `<reg: u8>`                                       | Push 8-bit value at memory address stored in register onto the stack                                          | `psh8 [r1]`             | `----` |
| psh16    | OP_PUSH16_REGPTR     | `<reg: u8>`                                       | Push 16-bit value at memory address stored in register onto the stack                                         | `psh16 [r1]`            | `----` |
| psh32    | OP_PUSH32_REGPTR     | `<reg: u8>`                                       | Push 32-bit value at memory address stored in register onto the stack                                         | `psh32 [r1]`            | `----` |
| psh64    | OP_PUSH64_REGPTR     | `<reg: u8>`                                       | Push 64-bit value at memory address stored in register onto the stack                                         | `psh64 [r1]`            | `----` |
| psh      | OP_PUSHN_REGPTR      | `<bytes: u8>`, `<reg: n>`                         | Push n-byte value at memory address stored in register onto the stack                                         | `psh 12, [r1]`          | `----` |
| ret      | OP_RET               |                                                   | Return from a subroutine                                                                                      | `ret`                   | `----` |
| sar      | OP_ARSHIFT_LIT       | `<reg: u8>`, `<lit: u8>`                          | Arithmetically shift value in register right`lit` bits                                                        | `sar r2, 3`             | `**00` |
| sar      | OP_ARSHIFT_REG       | `<reg: u8>`, `<reg: u8>`                          | Arithmetically shift value in register right n-bits, where`n` is value in the second register                 | `sar r2, r3`            | `**00` |
| sll      | OP_LLSHIFT_LIT       | `<reg: u8>`, `<lit: u8>`                          | Logically shift value in register left`lit` bits                                                              | `sll r2, 3`             | `**00` |
| sll      | OP_LLSHIFT_REG       | `<reg: u8>`, `<reg: u8>`                          | Logically shift value in register left n-bits, where`n` is value in the second register                       | `sll r2, r3`            | `**00` |
| slr      | OP_LRSHIFT_LIT       | `<reg: u8>`, `<lit: u8>`                          | Logically shift value in register right`lit` bits                                                             | `slr r2, 3`             | `**00` |
| slr      | OP_LRSHIFT_REG       | `<reg: u8>`, `<reg: u8>`                          | Logically shift value in register right n-bits, where`n` is value in the second register                      | `slr r2, r3`            | `**00` |
| sub      | OP_SUB_REG_LIT       | `<reg: u8>`, `<lit: word>`                        | Subtract a literal from a register as integers                                                                | `sub r1, 10`            | `----` |
| sub      | OP_SUB_REG_REG       | `<reg: u8>`, `<reg: u8>`                          | Subtract two registers as integers, storing the result in the first register                                  | `sub r1, r2`            | `----` |
| sub      | OP_SUB_MEM_MEM       | `<bytes: u8>`, `<addr1: uword>`, `<addr2: uword>` | Subtract two n-bytes buffers (buf1 - buf2) at the addresses and store result at the first address             | `sub 128, [200], [328]` | `----` |
| subf32   | OP_SUBF32_REG_LIT    | `<reg: u8>`, `<lit: f32>`                         | Subtract a literal from a register as 32-bit floats                                                           | `subf32 r1, 10`         | `----` |
| subf32   | OP_SUBF32_REG_REG    | `<reg: u8>`, `<reg: u8>`                          | Subtract two registers as 32-bit floats, storing the result in the first register                             | `subf32 r1, r2`         | `----` |
| subf64   | OP_SUBF64_REG_LIT    | `<reg: u8>`, `<lit: f64>`                         | Subtract a literal from a register as 64-bit floats                                                           | `subf64 r1, 10`         | `----` |
| subf64   | OP_SUBF64_REG_REG    | `<reg: u8>`, `<reg: u8>`                          | Subtract two registers as 64-bit floats, storing the result in the first register                             | `subf64 r1, r2`         | `----` |
| syscall  | OP_SYSCALL           | *N/A*                                             | Invokes a syscall (operation in `r0`).                                                                        | `syscall`               | `----` |
| xor      | OP_XOR_REG_LIT       | `<reg: u8>`, `<lit: word>`                        | Compute bitwise XOR of register and literal and place the result in register                                  | `xor r1, 101b`          | `**00` |
| xor8     | OP_XOR8_REG_LIT      | `<reg: u8>`, `<lit: u8>`                          | Compute bitwise XOR of register and 8-bit literal and place the result in register                            | `xor8 r1, 101b`         | `**00` |
| xor16    | OP_XOR16_REG_LIT     | `<reg: u8>`, `<lit: u16>`                         | Compute bitwise XOR of register and 16-bit literal and place the result in register                           | `xor16 r1, 101b`        | `**00` |
| xor32    | OP_XOR32_REG_LIT     | `<reg: u8>`, `<lit: u32>`                         | Compute bitwise XOR of register and 32-bit literal and place the result in register                           | `xor32 r1, 101b`        | `**00` |
| xor64    | OP_XOR64_REG_LIT     | `<reg: u8>`, `<lit: u64>`                         | Compute bitwise XOR of register and 64-bit literal and place the result in register                           | `xor64 r1, 101b`        | `**00` |
| xor      | OP_XOR_REG_REG       | `<reg: u8>`, `<reg: u8>`                          | Compute bitwise XOR of two registers and place the result in the first register                               | `xor r1, r2`            | `**00` |
| xor      | OP_XOR_MEM_MEM       | `<bytes: u8>`, `<addr: uword>`, `<addr: uword>`   | Compute bitwise XOR of two`byte`-length buffers at the addresses and store result in the first address        | `xor 12, [200], [212]`  | `**00` |

## Notes

- Comparison Operations. Compare `a` to `b`, and set `REG_CMP` appropriately:
  - `a < b` : `CMP_LT`
  - `a = b` : `CMP_EQ`
  - `a > b` : `CMP_GT`
